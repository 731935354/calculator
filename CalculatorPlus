package cal;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTabbedPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.ScrollPaneConstants;
import javax.swing.UIManager;

import org.jb2011.lnf.beautyeye.BeautyEyeLNFHelper;

import java.lang.Math;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.StringTokenizer;


public class CalculatorPlus extends JFrame implements ActionListener{
	
	/**
	 * 
	 */
	private static final long serialVersionUID = -5173182779209880069L;
	/**
	 * Science界面
	 */
	//AC与退格键
	JButton backspace = new JButton("←");
	JButton AC = new JButton("AC");
	//15个函数功能键的名字
	private final String[] FUNC_KEYS = {"Abs", "sin", "cos", "x^2", "x^3", "%", "tan", "deg-rad", "^", "1/x", "π", "log", "ln", "x!", "√x",  
             };
	//15个函数功能键
    private JButton func_keys[] = new JButton[FUNC_KEYS.length];
    //计算器下方数字和运算符键的名字
    private final String[] KEYS = { "7", "8", "9", "*", "(", "4", "5", "6",
            "/", ")", "1", "2", "3", "+", "=", "0", ".", "-" };
    //计算器下方数字和运算符键
    private JButton keys[] = new JButton[KEYS.length];
    //Science界面文本显示区域
    JTextField reText = new JTextField("0");
    /**
	 * finance界面
	 */ 
    //finance界面文本显示区域
    JTextField fText = new JTextField("0");
    //按键
    JButton backspace_2 = new JButton("←");
    JButton AC_2 = new JButton("AC");
    private final String[] F_KEYS = {"tv", "ctv", "EAR", "call/put", "t", "r", "x", "y", "Average", "Forward", "CForward", "Enter"};
    private JButton f_keys[] = new JButton[F_KEYS.length];
    private final String[] KEYS_2 = {"7", "8", "9", "4", "5", "6", "1", "2", "3", "0", "."};
    private JButton keys_2[] = new JButton[KEYS_2.length];
    
    /**
	 * Matrix界面
	 */
    //matrix界面文本显示区域
    JTextArea MatrixText = new JTextArea("input matrix here:", 10, 10);
    // 按钮
    private final String[] MATRIX_KEYS = {"←", "AC", "=", "Add", "Dif", "Mul", "Det", "Rank", "UpT", "Eig",
    		"Rev", "Tra"};
    private JButton matrix_keys[] = new JButton[MATRIX_KEYS.length];
    /**
     * 变量部分
     */
    private ArrayList<String> list;//记录输入字符
    
    private boolean vbegin = true;// 控制输入，true为重新输入，false为接着输入  
    private boolean equals_flag = true;// true为未输入=，false表示输入=  
    private boolean isContinueInput = true;// true为正确，可以继续输入，false错误，输入锁定  
  
    final int MAXLEN = 500;  
    final double  PI = 3.141592657;
    double resultNum = 0.0;//存储计算结果
    
    
	public CalculatorPlus() {
        super();
        // 初始化计算器
        init();
        // 设置计算器的背景颜色
        this.setBackground(Color.LIGHT_GRAY);
        // 设置文字标题
        this.setTitle("计算器加强版（可显示算式）");
        //居中显示
        this.setLocationRelativeTo(null);
        //默认退出  
        this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        // 设置窗体大小
        this.setSize(435, 575);
        // 不许修改计算器的大小
        this.setResizable(false);
    }
	
	//初始化计算器
	private void init() {
        initWindow(); //初始化界面
        initActionEvent();  //添加事件处理
	}
	
	public void initWindow() {
		//采用TabbedPane,实现多标签切换,共有3个选项卡		
		JTabbedPane background = new JTabbedPane(JTabbedPane.NORTH);//选项卡位于界面上方
				
		//初始化science面板
		JPanel Pane1 = new JPanel();
		Pane1.setLayout(null);//设置布局NULL，采用绝对布局
				
		//文本显示区域
		reText.setBounds(28, 20, 370, 120);//设置文本框区域位置及大小
		reText.setHorizontalAlignment(JTextField.RIGHT);// 文本框中的内容采用右对齐方式
	    reText.setEditable(false);// 不允许修改结果文本框
		reText.setFont(new Font("楷体",Font.BOLD,30));//设置文本字体及大小
		Pane1.add(reText); // 将文本显示区域加入面板
		list = new ArrayList<String>(); 
				
	    //加入2个功能键   
		Pane1.add(backspace);
		backspace.setBounds(298, 155, 100, 30);
		Pane1.add(AC);
		AC.setBounds(28, 155, 100, 30);
		        
		// 初始化计算器上15个函数功能键的按钮
        for(int i = 0; i < 15; i++) {
        	func_keys[i] = new JButton(FUNC_KEYS[i]);
        	Pane1.add(func_keys[i]);
        	func_keys[i].setBounds(i%5*(66+10)+28, i/5*(24+10)+200, 66, 25);
        }
        
        // 初始化计算器下方18个按键
        for(int i = 0; i < 14; i++) {
        	keys[i] = new JButton(KEYS[i]);
        	Pane1.add(keys[i]);
        	keys[i].setBounds(i%5*(66+10)+28, i/5*(35+10)+305, 66, 35);
        }
        //等号键
        keys[14] = new JButton(KEYS[14]);
        Pane1.add(keys[14]);
        keys[14].setBounds(14%5*(66+10)+28, 14/5*(35+10)+305, 66, 80);
        //0键
        keys[15] = new JButton(KEYS[15]);
        Pane1.add(keys[15]);
        keys[15].setBounds(28, 440, 142, 35);
        //"."和"-"键
        keys[16] = new JButton(KEYS[16]);
        Pane1.add(keys[16]);
        keys[16].setBounds(180, 440, 66, 35);
        keys[17] = new JButton(KEYS[17]);
        Pane1.add(keys[17]);
        keys[17].setBounds(256, 440, 66, 35);
         
        // 初始化finance面板
        JPanel Pane2 = new JPanel();
        Pane2.setLayout(null);
        // finance界面文本显示区域
        fText.setBounds(28, 20, 370, 120);
        fText.setHorizontalAlignment(JTextField.RIGHT);// 文本框中的内容采用右对齐方式
	    fText.setEditable(false);// 不允许修改结果文本框
		fText.setFont(new Font("楷体",Font.BOLD,30));//设置文本字体及大小
        Pane2.add(fText);
        // 初始化按键
        Pane2.add(backspace_2);
		backspace_2.setBounds(298, 155, 100, 30);
		Pane2.add(AC_2);
		AC_2.setBounds(28, 155, 100, 30);
		// 初始化12个函数功能键的按钮
        for(int i = 0; i < 12; i++) {
        	f_keys[i] = new JButton(F_KEYS[i]);
        	Pane2.add(f_keys[i]);
        	f_keys[i].setBounds(i%4*(85+10)+28, i/4*(30+10)+200, 85, 30);
        }
        
        // 初始化数字键
        for(int i = 0; i < 9; i++) {
        	keys_2[i] = new JButton(KEYS_2[i]);
        	Pane2.add(keys_2[i]);
        	keys_2[i].setBounds(i%3*(110+20)+28, i/3*(30+10)+325, 110, 30);
        }
        keys_2[9] = new JButton(KEYS_2[9]);
        keys_2[9].setBounds(28, 445, 240, 30);
        Pane2.add(keys_2[9]);
        keys_2[10] = new JButton(KEYS_2[10]);
        keys_2[10].setBounds(288, 445, 110, 30);
        Pane2.add(keys_2[10]);
		
        
        // 初始化matrix面板
        JPanel Pane3 = new JPanel();
        Pane3.setLayout(null);
        
        // matrix界面文本显示区域
        final JTextArea textArea = new JTextArea ( "input matrix here:\n" );
        final JScrollPane scrollPane = new JScrollPane ( textArea );
        scrollPane.setVerticalScrollBarPolicy ( ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS );
        scrollPane.setHorizontalScrollBarPolicy ( ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS );
        scrollPane.setBounds(28, 20, 370, 240);
        Pane3.add(scrollPane);
        
        // 初始化按键
        for(int i = 0; i < 12; i++) {
        	matrix_keys[i] = new JButton(MATRIX_KEYS[i]);
        }
        matrix_keys[0].setBounds(28, 285, 100, 30);
        matrix_keys[1].setBounds(298, 285, 100, 30);
        matrix_keys[2].setBounds(163, 285, 100, 30);
        Pane3.add(matrix_keys[0]);
        Pane3.add(matrix_keys[1]);
        Pane3.add(matrix_keys[2]);
        for(int i = 0; i < 9; i++) {
            matrix_keys[i+3].setBounds(i%3*(100+35)+28, i/3*(30+20)+335, 100, 30);
            Pane3.add(matrix_keys[i+2]);
        }
        
        //将三个面板加入tabbedpand
        background.add("Science",Pane1);
        background.add("Finance",Pane2);
        background.add("Matrix",Pane3);
        
        //将选项卡窗体加入到主窗体上
        getContentPane().add(background, BorderLayout.CENTER);
	}
	
	public void initActionEvent() {
		// 为各按钮添加事件侦听器
        // 都使用同一个事件侦听器，即本对象。本类的声明中有implements ActionListener
        backspace.addActionListener(this);//为3个按钮添加监听器
        AC.addActionListener(this);
        for (int i = 0; i < FUNC_KEYS.length; i++) { //为15个函数功能键添加监听器
            func_keys[i].addActionListener(this);
        }
        for (int i = 0; i < KEYS.length; i++) { //为18个数字及运算符键添加监听器
            keys[i].addActionListener(this);
        }
	}
	
	//处理事件
    public void actionPerformed(ActionEvent e) {
    	String label = e.getActionCommand(); // 获取事件源的标签
        if (label.equals("←")) {
            handleBackspace(); // 用户按了"Backspace"键
        } else if (label.equals("AC")) {
        	list.clear();  
            reText.setText("0");  
            vbegin = true;  
            equals_flag = true;  
        } else if (label.equals("Abs")) {
            handleAbs();
        } else if (label.equals("sin")) {
        	handleSin();
        } else if (label.equals("cos")) {
        	handleCos();
        } else if (label.equals("x^2")) {
        	handleSquare();
        } else if (label.equals("x^3")) {
        	handleCube();
        } else if (label.equals("%")) {
        	handlePercent();
        } else if (label.equals("tan")) {
        	handleTan();
        } else if (label.equals("1/x")) {
        	handleReciprocal();
        } else if (label.equals("log")) {
        	handleLog();
        } else if (label.equals("ln")) {
        	handleLn();
        } else if (label.equals("x!")) {
        	handleFact();
        } else if (label.equals("√x")) {
        	handleRadical();
        } else { 
            handle(label);  
        }  
    }
    
    //处理Abs键被按下的事件
    private void handleAbs() {
    	resultNum = getNumberFromText();
    	if(resultNum >= 0) {
    		reText.setText(String.valueOf(resultNum));
    	}
    	else {
    		reText.setText(String.valueOf(resultNum*(-1)));
    	}
    }
    
    //处理sin键被按下的事件
    private void handleSin() {
    	resultNum = Math.sin(resultNum*Math.PI/180);
    	reText.setText(String.valueOf(resultNum));
    }
    
    //处理cos键被按下的事件
    private void handleCos() {
    	resultNum = Math.cos(resultNum*Math.PI/180);
    	reText.setText(String.valueOf(resultNum));
    }
    
    //处理x^2键被按下的事件
    private void handleSquare() {
    	resultNum *= getNumberFromText();
    	reText.setText(String.valueOf(resultNum));
    }
    
    //处理x^3键被按下的事件
    private void handleCube() {
    	resultNum = getNumberFromText()*getNumberFromText()*getNumberFromText();
    	reText.setText(String.valueOf(resultNum));
    }
    
    //处理%键被按下的事件
    private void handlePercent() {
    	resultNum = resultNum/100;
    	reText.setText(String.valueOf(resultNum));
    }
    
    //处理tan键被按下的事件
    private void handleTan() {
    	resultNum = Math.tan(resultNum*Math.PI/180);
    	reText.setText(String.valueOf(resultNum));
    }
    
    //处理1/x键被按下的事件
    private void handleReciprocal() {
    	if (resultNum == 0.0) {
            // 操作不合法
            reText.setText("零没有倒数");
        } else {
            resultNum = 1 / resultNum;
        }
    	reText.setText(String.valueOf(resultNum));
    }
    
    //处理Log键被按下的事件
    private void handleLog() {
    	resultNum = Math.tan(resultNum*Math.PI/180);
    	reText.setText(String.valueOf(resultNum));
    }
    
    //处理Ln键被按下的事件
    private void handleLn() {
    	resultNum = Math.tan(resultNum*Math.PI/180);
    	reText.setText(String.valueOf(resultNum));
    }
    
    //处理x!键被按下的事件
    private void handleFact() {
    	resultNum = Math.tan(resultNum*Math.PI/180);
    	reText.setText(String.valueOf(resultNum));
    }
    
    //处理Ln键被按下的事件
    private void handleRadical() {
    	resultNum = Math.tan(resultNum*Math.PI/180);
    	reText.setText(String.valueOf(resultNum));
    }
    
    //处理backspace键被按下的事件
    private void handleBackspace() {  
        String text = reText.getText();  
        list.add(text);  
        int i = text.length();  
        if (i > 0 && list.size() > 0) {  
            text = text.substring(0, i - 1);  
            list.remove(list.size() - 1); // 移除栈顶的那个元素  
            if (text.length() == 0) {  
                list.clear();  
                reText.setText("0");  
                vbegin = true;  
                equals_flag = true;  
            } else {  
                reText.setText(text);  
            }  
        }  
    }
    
    public void handle(String key) {  
        String text = reText.getText();  
        if (equals_flag == false) { //&& "π0123456789.()+-*/^".indexOf(key) != -1  
            list.add(text);  
            vbegin = false; 
        }  
  
        if (!list.isEmpty()) {  
            TipChecker(list.get(list.size() - 1), key);  
        } else {  
            TipChecker("#", key);  
        }  
        if (isContinueInput && "π0123456789.()+-*/^".indexOf(key) != -1) {  
            list.add(key);  
        }  
  
        // 若输入正确，则将输入信息显示到显示器上  
        if (isContinueInput && "π0123456789.()+-*/^".indexOf(key) != -1) {  
            if (equals_flag == false && ("+-*/^".indexOf(key) != -1)) {  
                vbegin = false;  
                equals_flag = true;  
                printText(key);  
            } else if (equals_flag == false  
                    && ("π0123456789.()".indexOf(key) != -1)) {  
                vbegin = true;  
                equals_flag = true;  
                printText(key);  
            } else {  
                printText(key);  
            }  
  
        } else if (isContinueInput && equals_flag && key.equals("=")) {  
            isContinueInput = false;// 表明不可以继续输入  
            equals_flag = false;// 表明已经输入=  
            vbegin = true;// 重新输入标志设置true  
            process(reText.getText()); // 整个程序的核心，计算表达式的值并显示  
            list.clear();  
        }  
        isContinueInput = true;  
    }  
  
    private void printText(String key) {  
        if (vbegin) {  
            reText.setText(key);// 清屏后输出  
        } else {  
            reText.setText(reText.getText() + key);  
        }  
        vbegin = false;  
    } 
    
    /* 
     * 检测函数，对str进行前后语法检测 为Tip的提示方式提供依据，与TipShow()配合使用 编号 字符 其后可以跟随的合法字符 1 （ 
     * 数字|（|-|.|函数 2 ） 算符|）|  ^ 3 . 数字|算符|）|  ^ 4 数字 .|数字|算符|）|  ^ 5 算符 
     * 数字|（|.|函数 6   ^ （ |. | 数字 7 函数 数字|（|. 
     *  
     * 小数点前后均可省略，表示0 数字第一位可以为0 
     */  
    private void TipChecker(String tipcommand1, String tipcommand2) {  
        // Tipcode1表示错误类型，Tipcode2表示名词解释类型  
        int Tipcode1 = 0, Tipcode2 = 0;  
        // 表示命令类型  
        int tiptype1 = 0, tiptype2 = 0;  
        // 括号数  
        int bracket = 0;  
        // “+-*/ ^”不能作为第一位  
        if (tipcommand1.compareTo("#") == 0  
                && (tipcommand2.compareTo("/") == 0  
                        || tipcommand2.compareTo("*") == 0  
                        || tipcommand2.compareTo("+") == 0  
                        || tipcommand2.compareTo(")") == 0 || tipcommand2  
                        .compareTo("^") == 0)) {  
            Tipcode1 = -1;  
        }  
        // 定义存储字符串中最后一位的类型  
        else if (tipcommand1.compareTo("#") != 0) {  
            if (tipcommand1.compareTo("(") == 0) {  
                tiptype1 = 1;  
            } else if (tipcommand1.compareTo(")") == 0) {  
                tiptype1 = 2;  
            } else if (tipcommand1.compareTo(".") == 0) {  
                tiptype1 = 3;  
            } else if ("0123456789".indexOf(tipcommand1) != -1) {  
                tiptype1 = 4;  
            } else if ("+-*/".indexOf(tipcommand1) != -1) {  
                tiptype1 = 5;  
            } else if ("^".indexOf(tipcommand1) != -1) {  
                tiptype1 = 6;  
            }else if ("π".indexOf(tipcommand1) != -1){  
                tiptype1 = 7;  
            }  
            // 定义欲输入的按键类型  
            if (tipcommand2.compareTo("(") == 0) {  
                tiptype2 = 1;  
            } else if (tipcommand2.compareTo(")") == 0) {  
                tiptype2 = 2;  
            } else if (tipcommand2.compareTo(".") == 0) {  
                tiptype2 = 3;  
            } else if ("0123456789".indexOf(tipcommand2) != -1) {  
                tiptype2 = 4;  
            } else if ("+-*/".indexOf(tipcommand2) != -1) {  
                tiptype2 = 5;  
            } else if ("^".indexOf(tipcommand2) != -1) {  
                tiptype2 = 6;  
            }else if ("π".indexOf(tipcommand2) != -1){  
                tiptype2 = 7;  
            }  
              
  
            switch (tiptype1) {  
            case 1:  
                // 左括号后面直接接右括号,“+*/”（负号“-”不算）,或者" ^"  
                if (tiptype2 == 2  
                        || (tiptype2 == 5 && tipcommand2.compareTo("-") != 0)  
                        || tiptype2 == 6)  
                    Tipcode1 = 1;  
                break;  
            case 2:  
                // 右括号后面接左括号，数字，“+-*/^...π”  
                if (tiptype2 == 1 || tiptype2 == 3 || tiptype2 == 4|| tiptype2 == 7)  
  
                    Tipcode1 = 2;  
                break;  
            case 3:  
                // “.”后面接左括号，π  
                if (tiptype2 == 1 || tiptype2 == 7)  
                    Tipcode1 = 3;  
                // 连续输入两个“.”  
                if (tiptype2 == 3)  
                    Tipcode1 = 8;  
                break;  
            case 4:  
                // 数字后面直接接左括号和π  
                if (tiptype2 == 1 || tiptype2 == 7)  
                    Tipcode1 = 4;  
                break;  
            case 5:  
                // “+-*/”后面直接接右括号，“+-*/ ^”  
                if (tiptype2 == 2 || tiptype2 == 5 || tiptype2 == 6)  
                    Tipcode1 = 5;  
                break;  
            case 6:  
                // “ ^”后面直接接右括号，“+-*/ ^π”  
                if (tiptype2 == 2 || tiptype2 == 5 || tiptype2 == 6 || tiptype2 == 7)  
                    Tipcode1 = 6;  
                break;  
            case 7:  
                //"π"之后只能为"+-*/^)"不能为"π(.0123456789"  
                if (tiptype2 == 1 || tiptype2 == 3 || tiptype2 == 4 || tiptype2 == 7){  
                    Tipcode1 = 7;  
                }                     
                break;  
            }  
        }  
        // 检测小数点的重复性，Tipconde1=0,表明满足前面的规则  
        if (Tipcode1 == 0 && tipcommand2.compareTo(".") == 0) {  
            int tip_point = 0;  
            for (int i = 0; i < list.size(); i++) {  
                // 若之前出现一个小数点，则小数点计数加1  
                if (list.get(i).equals(".")) {  
                    tip_point++;  
                }  
                // 若出现以下几个运算符之一，小数点计数清零  
                if (list.get(i).equals("^") || list.get(i).equals("/")  
                        || list.get(i).equals("*") || list.get(i).equals("-")  
                        || list.get(i).equals("+") || list.get(i).equals("(")  
                        || list.get(i).equals(")")) {  
                    tip_point = 0;  
                }  
            }  
            tip_point++;  
            // 若小数点计数大于1，表明小数点重复了  
            if (tip_point > 1) {  
                Tipcode1 = 8;  
            }  
        }  
        // 检测右括号是否匹配  
        if (Tipcode1 == 0 && tipcommand2.compareTo(")") == 0) {  
            int tip_right_bracket = 0;  
            for (int i = 0; i < list.size(); i++) {  
                // 如果出现一个左括号，则计数加1  
                if (list.get(i).equals("(")) {  
                    tip_right_bracket++;  
                }  
                // 如果出现一个右括号，则计数减1  
                if (list.get(i).equals(")")) {  
                    tip_right_bracket--;  
                }  
            }  
            // 如果右括号计数=0,表明没有响应的左括号与当前右括号匹配  
            if (tip_right_bracket == 0) {  
                Tipcode1 = 10;  
            }  
  
        }  
        // 检查输入=的合法性  
        if (Tipcode1 == 0 && tipcommand2.compareTo("=") == 0) {  
            // 括号匹配数  
            int tip_bracket = 0;  
            for (int i = 0; i < list.size(); i++) {  
                if (list.get(i).equals("(")) {  
                    tip_bracket++;  
                }  
                if (list.get(i).equals(")")) {  
                    tip_bracket--;  
                }  
            }  
            // 若大于0，表明左括号还有未匹配的  
            if (tip_bracket > 0) {  
                Tipcode1 = 9;  
                bracket = tip_bracket;  
            } else if (tip_bracket == 0) {  
                // 若前一个字符是以下之一，表明=号不合法  
                if ("+-*/".indexOf(tipcommand1) != -1) {  
                    Tipcode1 = 5;  
                }  
            }  
        }  
  
        if (Tipcode1 != 0) {  
            isContinueInput = false;// 表明不可以继续输入  
        }  
    } 
    
    /* 
     * 计算表达式 从左向右扫描，数字入number栈，运算符入operator栈  
     * +-基本优先级为1， 
     * ×÷基本优先级为2， 
     * √^基本优先级为4  
     * 括号内层运算符比外层同级运算符优先级高4 
     * 当前运算符优先级高于栈顶压栈， 
     * 低于栈顶弹出一个运算符与两个数进行运算 
     * 重复直到当前运算符大于栈顶 
     * 扫描完后对剩下的运算符与数字依次计算 
     */  
    public void process(String str) {  
        int weightPlus = 0, topOp = 0, topNum = 0, flag = 1, weightTemp = 0;  
        // weightPlus为同一（）下的基本优先级，weightTemp临时记录优先级的变化  
        // topOp为weight[]，operator[]的计数器；topNum为number[]的计数器  
        // flag为正负数的计数器，1为正数，-1为负数  
        int weight[]; // 保存operator栈中运算符的优先级，以topOp计数  
        double number[]; // 保存数字，以topNum计数  
        char ch, ch_gai, operator[];// operator[]保存运算符，以topOp计数  
        String num;// 记录数字，str以+-*/() ! ^分段，+-*/() ^字符之间的字符串即为数字  
        weight = new int[MAXLEN];  
        number = new double[MAXLEN];  
        operator = new char[MAXLEN];              
        String expression = str.replace("π",String.valueOf(PI));//将字符串中的π用PI  
        // 建议用split代替字符串分割  
        StringTokenizer expToken = new StringTokenizer(expression, "+-*/()^");  
        int i = 0;  
        while (i < expression.length()) {  
            ch = expression.charAt(i);  
            // 判断正负数  
            if (i == 0) {  
                if (ch == '-')  
                    flag = -1;  
            } else if (expression.charAt(i - 1) == '(' && ch == '-')  
                flag = -1;  
            // 取得数字，并将正负符号转移给数字,E是科学计数  
            if (ch <= '9' && ch >= '0' || ch == '.' || ch == 'E') {  
                num = expToken.nextToken();//分割后的StringTokenizer中的下一个索引数据  
                ch_gai = ch;  
                // 取得整个数字  
                while (i < expression.length()  
                        && (ch_gai <= '9' && ch_gai >= '0' || ch_gai == '.' || ch_gai == 'E')) {  
                    ch_gai = expression.charAt(i++);  
                }  
                // 将指针退回之前的位置，即每个数字的末尾位置  
                if (i >= expression.length())  
                    i -= 1;  
                else {  
                    i -= 2;  
                }  
                if (num.compareTo(".") == 0)  
                    number[topNum++] = 0;  
                // 将正负符号转移给数字  
                else {  
                    number[topNum++] = Double.parseDouble(num) * flag;  
                    flag = 1;  
                }  
            }  
            // 计算运算符的优先级  
            if (ch == '(')  
                weightPlus += 4;  
            if (ch == ')')  
                weightPlus -= 4;  
            if (ch == '-' && flag == 1 || ch == '+' || ch == '*' || ch == '/'  
                    || ch == '^') {  
  
                switch (ch) {  
                // +-的优先级最低，为1  
                case '+':  
                case '-':  
                    weightTemp = 1 + weightPlus;  
                    break;  
                // x/的优先级稍高，为2  
                case '*':  
                case '/':  
                    weightTemp = 2 + weightPlus;  
                    break;  
                default:  
                    weightTemp = 4 + weightPlus;  
                    break;  
                }  
                // 如果当前优先级大于堆栈顶部元素，则直接入栈  
                if (topOp == 0 || weight[topOp - 1] < weightTemp) {  
                    weight[topOp] = weightTemp;  
                    operator[topOp] = ch;  
                    topOp++;  
                    // 否则将堆栈中运算符逐个取出，直到当前堆栈顶部运算符的优先级小于当前运算符  
                } else {  
                    while (topOp > 0 && weight[topOp - 1] >= weightTemp) {  
                        switch (operator[topOp - 1]) {  
                        // 取出数字数组的相应元素进行运算  
                        case '+':  
                            number[topNum - 2] += number[topNum - 1];  
                            break;  
                        case '-':  
                            number[topNum - 2] -= number[topNum - 1];  
                            break;  
                        case '*':  
                            number[topNum - 2] *= number[topNum - 1];  
                            break;  
                        // 判断除数为0的情况  
                        case '/':  
                            if (number[topNum - 1] == 0) {  
                                // showError(1, str_old);  
                                return;  
                            }  
                            number[topNum - 2] /= number[topNum - 1];  
                            break;  
  
                        case '^':  
                            number[topNum - 2] = Math.pow(number[topNum - 2],  
                                    number[topNum - 1]);  
                            break;  
                        // 计算时进行角度弧度的判断及转换  
                        }  
                        // 继续取堆栈的下一个元素进行判断  
                        topNum--;  
                        topOp--;  
                    }  
                    // 将运算符入堆栈  
                    weight[topOp] = weightTemp;  
                    operator[topOp] = ch;  
                    topOp++;  
                }  
            }  
            i++;  
        }  
        // 依次取出堆栈的运算符进行运算  
        while (topOp > 0) {  
            // +-x直接将数组的后两位数取出运算  
            switch (operator[topOp - 1]) {  
            case '+':  
                number[topNum - 2] += number[topNum - 1];  
                break;  
            case '-':  
                number[topNum - 2] -= number[topNum - 1];  
                break;  
            case '*':  
                number[topNum - 2] *= number[topNum - 1];  
                break;  
            // 涉及到除法时要考虑除数不能为零的情况  
            case '/':  
                if (number[topNum - 1] == 0) {  
                    // showError(1, str_old);  
                    return;  
                }  
                number[topNum - 2] /= number[topNum - 1];  
                break;  
  
            case '^':  
                number[topNum - 2] = Math.pow(number[topNum - 2],  
                        number[topNum - 1]);  
                break;  
  
            }  
            // 取堆栈下一个元素计算  
            topNum--;  
            topOp--;  
        }  
        // 如果是数字太大，提示错误信息  
        if (number[0] > 7.3E306) {  
            // showError(3, str_old);  
            return;  
        }  
        // 输出最终结果  
        reText.setText(String.valueOf(FP(number[0])));  
  
    }  
  
    public double FP(double n) {  
        DecimalFormat format = new DecimalFormat("0.#############");  
        return Double.parseDouble(format.format(n));  
    } 
    
    // 从结果文本框中获取数字
    private double getNumberFromText() {
        double result = 0;
        try {
            result = Double.valueOf(reText.getText()).doubleValue();
        } catch (NumberFormatException e) {
        }
        return result;
    }
	
    public static void main(String[] args)
	{
	    try
	    {
	    	// 设置皮肤
	    	BeautyEyeLNFHelper.frameBorderStyle = BeautyEyeLNFHelper.FrameBorderStyle.generalNoTranslucencyShadow;
	        org.jb2011.lnf.beautyeye.BeautyEyeLNFHelper.launchBeautyEyeLNF();
	        //取消显示“设置”选项
	        UIManager.put("RootPane.setupButtonVisible", false);
	        //控制JTabbedPane左缩进
	        UIManager.put("TabbedPane.tabAreaInsets"
	        	    , new javax.swing.plaf.InsetsUIResource(3,20,2,20));
	    }
	    catch(Exception e)
	    {
	        //TODO exception
	    }
	    new CalculatorPlus().setVisible(true);
	}

}

